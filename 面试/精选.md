# 精选
## 什么是行盒块盒

是指html中两种不同性质的属性

**块盒**

1. 独占一行 
2. 可以设置宽高 
3. 宽度默认是父元素宽度的100% 
4. 里面可以嵌套块级元素和行内元素

**行盒**

1. 不会独占一行 
2. 不能设置宽高
3. 宽度等于内容宽度 
4. 不允许嵌套块级元素
5. 子元素只能是文本或者行盒



## 什么是BFC

BFC 是块级格式化上下文（Block Formatting Context）的缩写，是指页面上一个独立的渲染区域，具有一定的渲染规则，其中的元素按照特定的规则进行布局， BFC 内部的元素不会影响外部元素的布局，也不受外部元素的影响。

- 根元素（`<html>`）
- 浮动元素（元素的 `float` 属性不是 `none`）
- 绝对定位元素（元素的 `position` 属性为 `absolute` 或者 `fixed`）
- 弹性布局容器（元素的 `display` 属性为 `flex` 或者 `inline-flex`）
- 网格布局容器（元素的 `display` 属性为 `grid` 或者 `inline-grid`）
- `overflow` 属性不为 `visible` 的块级盒子

**用处：**

- 解决浮动元素令父元素高度坍塌的问题
- 解决非浮动元素被浮动元素覆盖问题
- 解决外边距垂直方向重合的问题



## 什么是属性计算

每一个元素都有所有的属性， 一个元素从什么css属性都没有到什么ccs属性都有的过程

1. 确定声明值

   参考样式表中没有冲突的声明，作为 css 属性值

2. 层叠冲突

   对样式表有冲突的声明使用层叠规则，确定 css 属性值

   1. 重要性
      1. import 用户样式表
      2. import浏览器样式表
      3. 用户样式表
      4. 浏览器样式表

   2. 特殊性

      计算css选择器的权重

   3. 源代码次序

3. 使用继承

   对仍然没有值的属性，若可以继承则继承父元素的值

4. 使用默认值

   对仍没有值的属性，全部使用默认属性值



## @import

```css
@import "./index.css";
```

1. link 属于 HTML 标签，而@import 完全是 CSS 提供的方式
2. 加载顺序。使用 import 只有前一个 css 下载并解析之后才能引入后一个 css
3. 兼容性。老浏览器不支持@import
4. 使用 JS 控制 DOM 改变样式的时候只能使用 link,@import 不是 DOM 可以控制的

link 比 import 更好

## 媒体查询

通过媒体查询，可以实现响应式设计，使得网页在不同的设备上能够自适应不同的布局和样式。据设备的特性和属性，如屏幕宽度、设备方向、颜色、分辨率等，来应用特定的 CSS 样式。

1. _link_ 方法

_link_ 方法引入媒体类型其实就是在 _link_ 标签引用样式的时候，通过 _link_ 标签中的 _media_ 属性来指定不同的媒体类型，如下：

```html
<link rel="stylesheet" href="index.css" media="screen" />
<link rel="stylesheet" href="print.css" media="print" />
```

3. _@import_

_@import_ 引入媒体类型主要有两种方式，一种是在 CSS 样式表中通过 _@import_ 调用另一个样式文件，另外一种是在 _style_ 标签中引入。

> 注意：_IE6_ 和 _IE7_ 中不支持该方式

在样式文件中引入媒体类型：

```css
@import url("./index.css") screen;
```

在 _style_ 标签中引入媒体类型：

```html
<style>
  @import url("./index.css") screen;
</style>
```

4. _@meida_ 的方式

_@media_ 是 _CSS3_ 中新引进的一个特性，称为媒体查询。_@media_ 引入媒体也有两种方式，如下：

在样式文件中引入媒体类型：

```css
@media screen and (max-width: 600px) {
    body {
        font-size: 14px;
    }
    .container {
        width: 90%;
    }
}
```

## 层叠上下文

**层叠上下文**：层叠上下文是一种三维的概念，它是指一个独立的环境，其中的元素按照一定的规则在z轴上进行堆叠，不同层叠上下文之间的元素堆叠顺序互不影响，层叠上下文又会被当作整体在父级的层叠上下文中进行堆叠

**层叠等级**：层叠等级是决定元素在层叠上下文中的堆叠顺序的属性，使用z-index来指定

**层叠顺序**： 是指元素在层叠上下文中如何堆叠的规则。当多个元素发生层叠时，它们的显示顺序由层叠顺序来决定。

创建层叠上下文：

1. 给一个元素设置定位属性（position）并且值不为static，并且z-index的值不是auto
2. opacity 属性不为 1
3. transform 不为 none

## *flex* 布局

基于弹性盒模型的弹性布局

设置了 display: flex的被称为**Flex容器**

flex容器有两个轴，主轴和交叉轴，flex-direction可以设置主轴方向

容器属性：

- `flex-direction`：指定Flex项的排列方向（主轴方向）。
- `flex-wrap`：定义Flex项是否允许换行。
- `justify-content`：指定Flex项在主轴上的对齐方式。
- `align-items`：指定Flex项在交叉轴上的对齐方式。
- `align-content`：多行Flex项在交叉轴上的对齐方式。

子元素属性

- `flex-grow`：指定Flex项的放大比例。
- `flex-shrink`：指定Flex项的收缩比例。
- `flex-basis`：指定Flex项在未伸缩之前的大小。
- `order`：指定Flex项的排列顺序。

## 网格布局

Grid 布局是一种二维布局系统，可以将页面划分为行和列，使得元素可以按照网格的方式进行排列和定位

**Grid 容器属性**

- `display`: 指定一个元素为 Grid 容器。
- `grid-template-columns`: 定义 Grid 的列的大小和数量。
- `grid-template-rows`: 定义 Grid 的行的大小和数量。
- `grid-gap`: 设置网格之间的间隔（列间隔和行间隔）。
- `grid-template-areas`: 定义网格的布局，通过区域名称指定每个单元格的位置。
- `justify-items`: 定义 Grid 内部元素在水平方向的对齐方式。
- `align-items`: 定义 Grid 内部元素在垂直方向的对齐方式。

**Grid 项目属性**

- `grid-column`: 定义项目在网格中的列位置。
- `grid-row`: 定义项目在网格中的行位置。
- `justify-self`: 定义项目在网格中的水平对齐方式。
- `align-self`: 定义项目在网格中的垂直对齐方式。
- `grid-area`: 指定项目在网格中的区域名称。



## 绍下粘性布局（*sticky*）

- 在阈值内，相当于relative
- 在阈值外，相当于fixed

sticky 属性值有以下几个特点：

- 该元素并**不脱离文档流**，仍然保留元素原本在文档流中的位置。
- 元素固定的相对偏移是相对于**离它最近的具有滚动框的祖先元素**，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量

##  *CSS3* 中 *transition* 和 *animation* 的属性分别有哪些

*transition* 过渡动画：

- *transition-property*：指定过渡的 *CSS* 属性
- *transition-duration*：指定过渡所需的完成时间
- *transition-timing-function*：指定过渡函数
- *transition-delay*：指定过渡的延迟时间

*animation* 关键帧动画：

- *animation-name*：指定要绑定到选择器的关键帧的名称
- *animation-duration*：动画指定需要多少秒或毫秒完成
- *animation-timing-function*：设置动画将如何完成一个周期
- *animation-delay*：设置动画在启动前的延迟间隔
- *animation-iteration-count*：定义动画的播放次数
- *animation-direction*：指定是否应该轮流反向播放动画
- *animation-fill-mode*：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式
- *animation-play-state*：指定动画是否正在运行或已暂停

##  *png* 的类型

PNG图片主要有三个类型，分别为 PNG 8/ PNG 24 / PNG 32。

- `PNG 8`：PNG 8中的8，其实指的是8bits，相当于用2^8（2的8次方）大小来存储一张图片的颜色种类，2^8等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。
- `PNG 24`：PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0-255),G(0-255),B(0-255)，可以表达256乘以256乘以256=16777216种颜色的图片，这样PNG 24就能比PNG 8表示色彩更丰富的图片。但是所占用的空间相对就更大了。
- `PNG 32`：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。R(0~255),G(0~255),B(0~255),A(0~255)。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色，能表示更加丰富的图片颜色类型。

##  *positon* 属性

position 属性主要用来定位，常见的属性值如下：

- `absolute` 绝对定位，相对于 `static` 定位以外的第一个父元素进行定位。（脱离文档流）

- `relative` 相对定位，相对于其自身正常位置进行定位。

- `fixed` 固定定位，相对于浏览器窗口进行定位。（脱离文档流）

- `static` 默认值。没有定位，元素出现在正常的流中。

- `inherit` 规定应该从父元素继承 position 属性的值。
- `sticky` 粘性定位，当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置

## 清除浮动的方法

- clear 清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式： 

  ```css
  clear:both;
  height:0;
  overflow:hidden;
  ```

- 给父级添加overflow:hidden 清除浮动方法

- 万能清除法 after 伪类清浮动（现在主流方法，推荐使用）

## 盒模型

每个 HTML 元素都被看作是一个矩形的盒子，这个盒子由四个部分组成：内容（Content）、内边距（Padding）、边框（Border）、外边距（Margin）。

- 标准盒模型：元素的宽度和高度只包括内容（content），不包括内边距（padding）、边框（border）和外边距（margin）。
- IE盒模型：元素的宽度和高度包括内容（content）、内边距（padding）和边框（border），但不包括外边距（margin）。

## 图片优化

1. CSS、SVG替代

2. 小图使用 *base64* 格式

3. 将多个图标文件整合到一张图片中（雪碧图）

## 渐进式渲染（*progressive rendering*）

渐进式渲染是用于提高网页性能（尤其是提高用户**感知**的加载速度），以尽快呈现页面的技术

**逐步呈现内容**：首先加载并显示页面的基本结构和内容，然后再逐步加载和呈现其他资源和元素，如图像、样式表和脚本等

**懒加载：** 将页面内容分成多个段落或块，并按需加载。当用户滚动页面时，动态加载并显示新的内容块，而不是一次性加载整个页面。这种方式可以减少首次加载时间，提高页面的响应速度。

- `getBoundingClientRect`可计算相当于视口的距离，在滚动条事件中动态加载图片

  ```js
  // 用可视区域高度减去图片顶部距离可视区域顶部的高度
  const distance = document.documentElement.clientHeightt - img.getBoundingClientRect().top;
  if (distance >= 0) {
       // 给图片赋值真实的src，展示图片
  }
  ```

- 使用`Intersection Observer`API，监测目标元素与其祖先元素或视口的交叉状态的 API

  ```js
  let observerImg = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
  		if(entry.isIntersecting){
  			// 替换为正式的图片
  			entry.target.src = entry.target.dataset.src;
  			// 停止监听
  			observer.unobserve(entry.target);
  		}
       });
  });
  let imgs = document.getElementsByClassName('lazyImg')
   
  for (let i = 0; i < imgs.length; i++) {
        //调用observe方法给元素加上监听,就是插个眼先,一但这个元素进入浏览器的视野就会回调callback函数
  	  observerImg.observe(imgs[i])
  }
  ```

  

## HTML页面生命周期

1. **DOMContentLoaded**

​	浏览器已经加载完成HTML数据，并且构建了DOM树。但是如样式、图片之类的外部文件有可能仍未加载完成。

2. **onload**

​	浏览器已经加载完全部的HTML以及图片、样式等外部资源。

3. `beforeunload/unload` 

    用户正在离开页面：可以询问用户是否保存了更改以及是否确定要离开页面。

## 页面布局

1. **静态布局（Fixed Width Layout）：**
   
   - 在固定宽度布局中，页面的宽度是固定的，通常以像素为单位。内容区域的宽度不会随着屏幕大小的变化而改变，而是始终保持不变。
   - 这种布局适用于那些希望页面在各种设备上呈现一致外观，并且不需要适应不同屏幕尺寸的情况。
2. **流式布局（Fluid Layout）：**
   - 流式布局是指页面的宽度相对于视口的宽度而言是动态调整的。通常使用百分比作为单位来定义宽度，使得页面的布局可以根据屏幕尺寸的变化而自动调整。
   - 这种布局适用于需要适应不同屏幕尺寸的情况，可以提供更好的跨设备兼容性和用户体验。
3. **栅格化布局（Grid Layout）：**
   - 栅格化布局是指使用网格系统来构建页面布局，将页面划分为多个列和行，然后将内容放置在这些列和行中。每个元素可以跨越一个或多个列或行。
   - 这种布局提供了更灵活的布局方式，可以实现复杂的页面结构和设计，并且适用于响应式设计。
4. **响应式布局（Responsive Layout）：**
   
   - 即 *Responsive Layout*，其目标是确保一个页面在所有终端（各种尺寸的 PC、手机、电视等）都能完美展现，对于开发人员来说通常是结合了流式布局 + 弹性布局 + 媒介查询。分别为不同屏幕分辨率定义布局。
   
     其特点在于：每个屏幕分辨率下都会有一个布局样式，元素位置、尺寸都会随之发生改变。使用多种布局方法配合，如果足够耐心效果完美。但缺点在于：媒介查询有限只能适应主流宽高，需要匹配足够多的屏幕大小工作量巨大，设计和开发都要需要多个版本。
   - 兼容各种设备工作量大，效率低下
   - 代码累赘，会出现隐藏无用的元素，加载时间加长

## CSS hack

浏览器不同或者版本不同，对css解析不一样，会导致不同浏览器中页面呈现效果不一致，为了在不同浏览器中获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，把这个过程叫做CSS hack

1. **选择器 hack：** 使用不同的 CSS 选择器来针对不同的浏览器应用样式。例如，通过使用 `*` 或者 `_` 作为前缀来应用特定的样式，或者使用属性选择器针对特定的浏览器版本。
2. **属性 hack：** 根据不同浏览器对 CSS 属性的支持情况来应用样式。例如，通过添加 `-webkit-`、`-moz-`、`-ms-`、`-o-` 等前缀来为 WebKit、Gecko、Trident、Opera 等浏览器应用特定样式。
3. **条件注释 hack：** 在 HTML 中使用条件注释来针对特定的 IE 浏览器版本应用样式。这种方法主要用于解决旧版 IE 浏览器的兼容性问题。

## less、sass是什么

*Less* 和 *Sass* 被称之为 *CSS* **预处理器**,可以让开发者在编码过程中使用变量、嵌套规则、函数等额外功能。最后还是会通过编译器将使用新语法的文件输出为一个 *CSS* 文件。常见的预处理器有 *less、sass、stylus*。

## 如何处理页面兼容性

1. 遵循W3C标准编码
2. CSS reset:清除默认样式，使各浏览器表现得一致
3. CSS hack

## 选择器的类型

- 元素选择器：例如 *div{…} p{...}*
- id 选择器： 例如 *#box{...}*
- 类选择器： 例如 *.box{...}*
- 属性选择器：*[href="#"]{...}*
- 通配：\*{...}
- 组合（并集）选择器：*div,p,a,.main{...}*
- 交集选择器：*input[type="text"]{...}*
- 后代选择器：*header nav{...}*
- 子级选择器： *ul>li{...}*
- 伪类选择器：
  - *:nth-child(num){...}*
  - *:nth-of-type{...}*
  - :not()：选择不匹配指定选择器的元素。
  - *:hover{...}*
  - *a:active{...}*
- 伪元素选择器：
  - *::before{...}*
  - *::after{...}*

## 为何 *CSS* 放在 *HTML* 头部

为了尽早让浏览器拿到 *CSS* 并且生成 *CSSOM*，然后与 *HTML* 一次性生成最终的 *RenderTree*，渲染一次即可。如果放在 *HTML* 底部，会出现渲染卡顿的现象影响性能和用户体验



## 解析 css 选择器

1. **选择器分解**：首先，浏览器会将整个选择器根据其组成部分分解成各个简单的选择器片段，例如标签名、类名、ID等。

2. **从右向左匹配**：然后，浏览器从选择器的最右边开始，逐步向左匹配元素。它会找到文档中与最右边的选择器片段匹配的所有元素。

3. **过滤**：接着，浏览器会根据匹配的元素以及其父元素、祖先元素等进行进一步的过滤。它会检查每个匹配元素的父元素、祖先元素是否也符合选择器的要求，以确定最终的匹配结果。

4. **计算样式**：最后，浏览器根据匹配的元素以及其对应的 CSS 规则，计算出最终的样式，并应用到文档中的元素上。

   

## 文本换行

```css
p{
	word-wrap: break-word;
	word-break: break-all;
	overflow: hidden;
}
```

## 文本溢出

**单行**

```css
<style>
    p{
        overflow: hidden;
        line-height: 40px;
        width:400px;
        height:40px;
        border:1px solid red;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
</style>
```

**多行**

1. 伪元素 + 定位

```css
<style>
    .demo {
        position: relative;
        line-height: 20px;
        height: 40px;
        overflow: hidden;
    }
    .demo::after {
        content: "...";
        position: absolute;
        bottom: 0;
        right: 0;
        padding: 0 20px 0 10px;
    }
</style>
```

2. 纯css（webkit）

```css
  p {
        width: 400px;
        border-radius: 1px solid red;
        -webkit-line-clamp: 2;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
    }
```

3. js

   ```js
   $(function(){
    //获取文本的行高，并获取文本的高度，假设我们规定的行数是五行，那么对超过行数的部分进行限制高度，并加上省略号
      $('p').each(function(i, obj){
           var lineHeight = parseInt($(this).css("line-height"));
           var height = parseInt($(this).height());
           if((height / lineHeight) >3 ){
               $(this).addClass("p-after")
               $(this).css("height","60px");
           }else{
               $(this).removeClass("p-after");
           }
       });
   })
   ```



## 内外边距取值

- 1个值： *margin {10px;}* 表示上右下左
- 2个值： *margin {10px 20px ;}* 表示上下 左右
- 3个值： *margin {10px 20px 30px;}* 表示上  左右 下
- 3个值： *margin {10px 20px 30px 40px ;}* 表示上 右 下 左

## HTML实体

实体（Entity）是一种特殊的文本表示形式来避免字符可能会与 HTML 的语法冲突

- &lt表示小于号 `<`
- &gt表示大于号 `>`

## 像素

1. 设备像素(物理像素)

​	1个设备像素就代表1个真实的像素点，是设备能控制显示的最小单位，我们常说的1920×1080像素分辨率就是用的设备像素单位。

2. 设备独立像素(逻辑像素)

​	与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素。

​	举个例子，一个屏幕的物理像素是2560*1440，但是我们可以人为定义这个屏幕就是1280*720，所以1个设备独立像素就用4个设备像素显示。

3. css像素

   css像素适用于web编程，指的是我们在样式代码中使用到的逻辑像素，是设备独立像素的一种，默认情况下 1css像素=1设备独立像素。

4. dpr

   设备像素/设备独立像素

5. ppi

   即每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。

## CSS性能优化

- 内联首屏关键CSS
- 压缩
- 避免多级嵌套
- 避免重排重绘属性
- 不要使用@import

## JS异步与事件循环

都说JS是单线程的语言，这其实因为JS运行在浏览器的渲染主线程中，而在一个标签页内，渲染主线程只有一个。

浏览器是个很复杂的系统，有很多的进程，比如浏览器进程、网络进程、渲染进程。而在渲染进程中，渲染主线程用来解析HTML文档，渲染页面，执行JS代码。由于JS能控制DOM，所以JS就只能在渲染主线程中阻塞式的运行，过长时间的计算就会导致不能及时渲染页面，从而掉帧卡顿。

解决这一问题的方法就是JS异步，而异步工作的基础就是事件循环。

事件循环是浏览器渲染主线程的工作方式，简单来说就是会开启一个永不停止的循环，每次循环会从任务队列中调度任务进行执行，并且每次执行任务的时候不会被打断。这样像JS异步代码就可以在别的线程中执行完成后，将任务放入消息队列中，等待事件循环调度执行，这通常是运行回调函数。

在过去，消息队列被分为宏任务队列和微任务队列，都是队列所以是先进先出。当渲染主线程空闲的时候，会优先执行微任务队列的任务，只有当微任务队列被清空全部执行完了，才会去调度宏任务队列任务执行。

但是现在随着前端的发展，仅仅是两条队列往往不再能满足需求。根据w3c的标准，现在宏任务队列可以变为多条具有不同优先级的消息队列，事件循环的时候浏览器可以选择调度不同优先级队列中的任务，但是微任务队列还是同样存在的。

所以JS异步任务就是放到其他线程中执行，等到执行完成之后，再通过事件循环机制等待渲染主线程空闲的时候继续执行。



## Node事件循环

Nodejs是异步、非IO阻塞的js运行环境，事件循环它实际上是一种基于时间的轮询机制，保持程序一直运行并持续进行 IO 操作的同时，不会阻塞或影响主线程的执行。

当 Node.js 启动时，它会开启一个循环，监听 并处理事件队列中I/O 事件和定时器事件。在事件循环过程中会优先处理微任务，微任务队列中的事件处理完了之后再处理宏任务队列中的事件。

宏队列包括

- timers

  执行`setTimeout、setInterval`回调

- poll

  除了timers、checks的回调比如IO都在这个队列

  如果别的队列为空，则在此等待

- checks 

  执行`setImmediate`回调


微队列包括

- nextTick 比promise优先级更高
- Promise

当没有事件时，事件循环会等待在POLL位置，

## 浏览器的理解

览器的主要功能是从服务器检索 *Web* 资源并将其显示在 *Web* 浏览器窗口中，Web资源通常是 *HTML* 文档，但也可能是 *PDF*、图像、音频、视频或其他类型的内容，资源的位置是通过使用 *URI*（统一资源标识符）指定的。

- 用户界面

  用户界面是你在屏幕上看到的浏览器的各种组件，包括地址栏、书签栏、前进和后退按钮、菜单等。它提供了与浏览器交互的途径。

- 浏览器引擎

  浏览器引擎是负责解析用户界面与渲染引擎之间交互的核心组件。它接收用户界面传递过来的操作请求，并将其转换为渲染引擎能够理解的指令。

- 渲染引擎

  即浏览器内核，渲染引擎负责解析HTML和CSS，并将其渲染成屏幕上可见的网页。

- 网络

  网络组件负责处理网络请求和响应，它与网络通信，从服务器请求网页内容，并将内容传递给渲染引擎进行处理。它还负责处理Cookie、缓存等网络相关的功能。

- *JS* 解释器

  JavaScript解释器用于解释和执行网页中的JavaScript代码。渲染引擎解析到js代码会暂停html的解析，交给js解析器解释执行，渲染引擎再根据执行结果继续渲染网页。

- 用户界面后端

  用于绘制基本的窗口小部件，比如下拉列表、文本框、按钮等，向上提供公开的接口，向下调用操作系统的用户界面。

- 数据存储

  这是一个持久层。浏览器可能需要在本地保存各种数据，例如 *cookie*。浏览器还支持 localStorage、IndexedDB 等存储机制。


## HTML解析过程

当网络线程收到一个html文档的时候，会产生一个渲染任务，放入消息队列中

在事件循环机制的作用下，渲染主线程取出消息队列中的渲 染任务，开启渲染流程

- HTML 解析

  解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。

  如果主线程解析到 Link 位置，不会等待继续解析后续的 HTML。因为下载和解析 CSS 的工作是在预解析线程中进行的，所以CSS 不会阻塞 HTML 解析。

  解析到Script位置，会停止解析 HTML等待 JS 文件下载好并执行完成后，才能继续解析 HTML，这是因为js会修改dom，所以js会阻塞HTML解析。

  解析完成后得到的就是DOM树和CCSOM树

- 样式计算

​	根据css计算规则（无冲突->冲突层叠->继承->默认值），同时一些相对值会被计算为绝对值，生成带css样式的DOM树

- 布局

  生成布局树，和DOM不一样，比如display：none的节点layout树中不会有，layout树中还有伪元素、匿名行盒、匿名块盒等

- 分层

​	会对布局树进行分层，将来某个元素改变后，仅会对该层进行后续处理，提高性能

- 生成绘制指令

​	为每层生成绘制指令

- 分块

  从现在开始交给合成线程，会将每层分出很多个小块

- 光栅化

  将每个小块生成位图，会优先生成靠近视口的位图

- 画

  合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。

  指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。

  将指引信息给GPU，在屏幕上绘制

其中重绘指的就是绘制到画的过程

重排和回流指的就是布局到画的过程

## async、defer、preload、prefetch

async：html解析过程中，边下载js文件，但是执行的时候会阻塞

defer: html解析过程中，边下载js文件，但是执行的时候会放在最后执行

preload： 它通过声明向浏览器声明一个需要提前加载的资源

prefetch：_prefetch_ 是一种利用浏览器的空闲时间加载页面将来可能用到的资源的一种机制，通常可以用于加载非首页的其他页面所需要的资源，以便加快后续页面的首屏速度

## Webwork

JS是单线程语言，运行在浏览器的渲染主线程上，如果遇到长时间的计算，就会阻塞渲染。WebworkAPI就可以创建后台运行的线程，这个线程被称之为 _Worker_。如通过加载一个 _JS_ 文件来进行大量复杂的计算，而不挂起主进程。

- 通过 _**postMessage**_ 和 _**onMessage**_ 进行通信。

- 可以在 _Worker_ 中通过 _importScripts(url)_ 方法来加载 _JavaScript_ 脚本文件。
- 可以使用 _setTimeout( )，clearTimeout( )，setInterval( ) 和 clearInterval( )_ 等方法。
- 可以使用 _XMLHttpRequest_ 进行异步请求。
- 不能跨域加载 _JavaScript_
- _Worker_ 内代码不能访问 _DOM_

## 跨标签页通讯

1. 服务器
2. localstorage（监听变化,同源）
3. 广播（BroadcastChannel，同域）
4. cookie 定时器轮询(setInterval，同域)
5. postMessage（跨域）

## 五层网络模型

- **物理层（Physical Layer）**
  - 物理介质上的数据传输
  - 01 信号
  - 网线
- **数据链路层（Data Link Layer）**
  - 01信号的含义，局域网内数据传输
  - 帧
  - 以太网协议、Mac 地址、集线器
- **网络层（Network Layer）**
  - 子网间传输，不是一个子网则路由传输，是则广播（每个设备都有固定 mac 和可变 ip 地址，先 ip 寻找到子网，在 mac 寻址传输）
  - IP 数据报
  - IP（Internet Protocol）、路由器
- **传输层（Transport Layer）**：
  - **端到端**通信
  - 数据段
  - TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）
- **应用层（Application Layer）**：
  - 为操作系统或应用程序提供访问网络服务的接口
  - HTTP、FTP、SSH

## HTTP 协议请求和响应格式

- 请求

  - 请求行
    - 方法 ( GET )
    - 请求目标（/index.html）
    - 版本（HTTP/1.1）
  - 请求头
    - **Host**：请求的主机名和端口（www.to.com）
    - **Referer**：请求来源的地址（www.from.com）
    - **Accept**：客户端能够接受的内容类型（ text/html）
    - **Authorization**：认证信息（ Authorization: Bearer token）
    - **Cookie**：客户端的 cookie 信息（ Cookie: sessionId=abc123）
    - **Content-Type**：请求体的内容类型（ Content-Type: application/json）
    
  - 请求体（可选）

- 响应

  - 状态行
    - **协议版本（HTTP Version）**：使用的 HTTP 协议版本，如 HTTP/1.1
    - **状态码（Status Code）**：表示响应的状态码，如 200, 404, 500 等
    - **状态消息（Status Message）**：描述状态码的简要信息，如 OK, Not Found, Internal Server Error
  - 响应头
    - **Content-Type**：响应体的内容类型（ Content-Type: text/html）
    - **Content-Length**：响应体的长度（ Content-Length: 1234）
    - **Set-Cookie**：设置客户端 cookie（ Set-Cookie: sessionId=abc123）
    - **Cache-Control**：缓存控制策略（ Cache-Control: no-cache
  - 响应体（可选）



## set-cookie 常用属性

- key-value

- Max-Age=seconds (优先级高)

- Expires=timestamp 

- Domain=domain-name（子域名共享）

- Path=path（子路径有效）

- Secure（只能 HTTPS 协议传输）

- HttpOnly (不能脚本读，只能请求携带)

- SameSite（跨域请求 cookie 携带策略）

  

## GET，POST

- get，post 都是 http 协议的请求方法，是请求行中的第一个单词

- 向服务器描述了客户端发出请求的动作类型

- 最大区别是数据一个在地址中一个在请求体中

- get 数据类型和大小有限制

- get 可以保存状态，当做书签

  

## Cookie/Session/SessionStorage/LocalStorage/IndexDB/CacheStorage

- cookie
  - 请求时自动携带
  - 传输内容小
  - 可以设置过期时间
  - 服务端可以主动设置
  - 常用于储存用户身份令牌
- session
  - 存储在服务端
  - 客户端会用 cookie 存 sessionId
  - 大小取决于服务端配置
  - 单点登录
- LocalStorage
  - 大小有限制，但是 比 cookie 大
  - 不会过期
  - 只能同源才能访问
  - 适合存储偏好设置、主题颜色
- SessionStorage
  - 关闭标签页失效
  - 其余和 localstorage 差不多
  - 常用于存储表单交互数据
- IndexDB
  - 没有大小限制
  - 数据库，支持结构化数据增删改查与事务
  - 复杂数据存储
- CacheStorage
  - 是服务 server worker 的，用于缓存静态资源
  - 大小和过期时间完全可控制
  - pwa 离线访问



## 加密

- 对称加密

  通过一个密钥加密解密，加密解密速度快，简单，但是分发密钥的时候容易被窃取

  在http中常用来当作会话密钥

- 非对称加密

  分公钥和私钥，一方加密另一方才能解密，只能一方才能解密

  ssl就是非对称加密

- 哈希

  密文占用空间小（定长的短字符串），不能解密

  常用做给明文密码加密



## 单点登录（SSO）

对于一个公司的多个产品，只需登录一次

1. **session + cookie**

   - 认证中心有所有人的身份凭证（redies）

   - 用户在子应用登录时，子应用每次都拿 cookie 去认证中心认证

2. **单token模式**

   - 第一次登录认证中心返回凭证

   - 子应用可以自己校验凭证

3. **双token模式**（访问 token + 刷新 token）
- 访问 token 过期时间短，子应用可以校验
   - 刷新 token 过期时间长，只有认证中心可以校验
- 访问 token 过期时，子应用自动拿着刷新 token 到认证中心请求新的访问 token（无感刷新）

## JWT

用于校验身份，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的

- header 标识签名算法和令牌类型(Base64)

- payload 标识主体信息，包含令牌过期时间、发布时间、发行者、主体内容等(Base64)

- signature 是使用特定的算法对前面两部分进行加密，得到的加密结果

  

## 同源策略（跨域）

- 不同源会跨域，源指的是 协议 + 主机+ 端口号

- 若页面源和页面运行过程中加载源不一致，出于安全考虑，**浏览器**会对跨域的资源访问进行一些限制

- 服务器代理

- cors

  - **简单请求**

    请求方法是get、post、head，请求头中只有安全字段，然后content-type也有限制（比如JSON就不行），这种请求浏览器不会发送预检请求，直接发送请求然后根据响应头中的数据判断是否接受跨域。

  - **需要预检的请求**

    会先发一种 OPTIONS 请求，也就是预检请求，根据服务器返回适当的 CORS 头部判断是否允许跨域，然后在发送真实的请求

  - **和附带身份信息的请求**

  ​	默认情况下，跨域请求并不会附带 cookie，但是可以通过手动配置加上，如果请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会先发送预检，并在请求头中添加`cookie`字段，询问服务器是否允许带cookie的请求

- jsonp



## 浏览器缓存

浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力

1. **不缓存**

   - 不使用缓存

   - cache-control: no-store

2. **强缓存**

   - 没过期就直接使用缓存
   - cache-control: max-age 过期时间、expire： 过期时刻
   - cache-control 优先级高

3. **协商缓存**

   - 每次都会发请求，如果缓存有效就返回 304，无效就返回新的资源

   - cache-control: no-cache, Eltag, last-modifed
   - 结合使用Eltag, last-modifed，先检查 Eltag，再检查 last-modifed

## 状态码

- 1 表示消息

  - 100 （继续请求）
  - 101 （切换协议）

- 2 表示成功

  - 200（成功并返回结果）
  - 201（成功并创建资源）
  - 202 (成功但没有处理)
  - 203（成功但没返回内容）

- 3 表示重定向
  
  - 301（永久重定向）
  
  - 302（临时重定向）
  
  - 304 （使用协商缓存）
  
- 4 表示请求错误

  - 400 （请求语法错误）

  - 401 （未授权）

  - 403 （禁止访问，权限不够）


    - 404（未找到）


    - 405 （请求方法不允许）



- 5 表示服务器错误

  - 500（服务器内部错误）

  - 502 （服务器或网关错误）

  

## **CSRF和XSS**

**csrf攻击**

CSRF 攻击是指利用用户的cookie，向用户登录过的网站恶意攻击

- 不用 cokkie

- 使用临时的 token

- 同源检测，cookie的same-site

**xss攻击**

脚本注入，比如在论坛网站中发表评论发表一段可执行的脚本，然后浏览器解析之后执行。

**输入验证**：对用户输入进行验证和过滤，确保只接受有效的输入。可以使用白名单过滤或正则表达式验证输入数据。

vue和react在编译模板和jsx的时候，会对一些特殊字符进行转义

## TCP

TCP 是一种**面向连接的、可靠**的协议，将数据分成 __数据段__ 传输，提供了**可靠数据传输和流量控制**

（UDP 是一种无连接的、不可靠的协议，它提供了简单的数据传输服务，不保证数据的可靠传输和顺序交付）

- 可靠传输

  - 校验和
  - 序列号
  - 确认应答机制
    - 数据段有序号，每个数据段传输都需要确认
  - 超时重传机制 （超时重传定时器）
    - 超过 2 RTT（正常数据段往返时间）自动重传
  - 连接管理机制
    - 三次握手
      - 客户端发送`SYN`报文，进入`SYN-SENT`状态
      - 服务端发送`SYN `+ `ACK`报文， 进入`SYN-RCVD`状态
      - 客户端发送`ACK`确认报文，进入`ESTAB_LISHED`状态
      - 服务端接收`ACK`确认报文，也进入`ESTAB_LISHED`状态
    - 四次挥手
      - Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，此后 Client 不能再向 Server 发送数据，但能读取数据。
      - Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据
      - Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态
      - Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据
      - Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。
      - Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源

- 流量控制（效率优化）

  - 滑动窗口

    - 滑动窗口支持异步的传输请求
    - 滑动窗口动态改变的窗口大小，tcp 数据段的首部有专门的窗口大小的部分

  - 快重传

    - 如果连续三次收到确认请求，则直接重传

  - 慢启动（拥塞窗口）

    - 拥塞窗口开始很小，慢慢增大

  - 延迟应答和捎带应答

    - 降低应答的频率，或者等待一小段时间再应答，让数据处理一会后，再返回更准确的窗口的大小
    - 延迟应答的基础上，在应答时捎带数据

  - 心跳检测（保活定时器）

    - 没有发数据就开启定时，定时到了进行探测，如果探测没有回复就断开连接

      

## HTTP版本

**http1.0**

它的特点是每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：

1. 无法复用连接

   每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低

2. 队头阻塞

   如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。

 **http1.1**

http1.1 是 http1.0 的改进版，它做出了以下改进：

1. 长连接

   http1.1 允许在请求时增加请求头`connection:keep-alive`，这样便允许后续的客户端请求在一段时间内复用之前的 TCP 连接

2. 管道化（徒有其表）

   基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。

3. 缓存处理

   新增响应头 cache-control，用于实现客户端缓存

**http2.0**

http2.0 进一步优化了传输效率，它主要有以下改进：

1. 二进制分帧

   将传输的消息分为更小的**二进制帧**， 帧代表着最小的数据单位，每帧有自己的**标识序号**，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流

2. 多路复用

   基于二进制分帧，在同一域名下所有访问都是从**同一个 tcp 连接**中走，并且不再有队头阻塞问题，也无须遵守响应顺序

   

3. 头部压缩

   http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量

4. 服务器推

   http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求

**http3.0**

使用UDP

## WEBSOCKET

- websocket 协议是 HTML5 的新协议，是基于 tcp 的全双工双向通讯协议
- websock 需要**利用 http 协议完成握手（协议升级）**,客户端请求协议升级，服务端返回 101

## DNS

域名的的作用就是帮助记忆ip

1. 检查缓存

   1. 浏览器缓存
   2. 操作系统缓存
   3. hosts 文件
   4. 递归查询过程中的 DNS 服务器缓存

2. 递归请求

   1. 根 DNS 服务器 

   2. 顶级 DNS 服务器 (TLD) 

   3. 权威 DNS 服务器

   4. 获取 IP 地址并返回给客户端



## SSL证书结构

- 私钥加密过的服务器公钥
- 域名
- 证书机构
- 私钥加密过的签名（机构公钥、域名、服务器公钥）

## SSL 握手过程

1. 客户端请求告知服务端接收的加密类型等信息

2. 服务端返回 SSL 证书，证书里包含了结构私钥加密的服务端公钥

3. 客户端校验证书，用机构公钥解密得到服务端公钥，客户端生成会话密钥，然后用服务端公钥加密，传给服务端

4. 服务端用私钥解密，得到会话密钥，并用会话密钥加密信息告知客户端准备就绪

5. 之后客户端和服务端都使用会话密钥通讯

   

## 输入URL之后发生了什么

1. 浏览器自动**补全**协议、端口
2. 浏览器自动完成url**编码**
3. 浏览器根据url地址查找本地**缓存**，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求
4. 通过**DNS**解析找到服务器的IP地址
5. 浏览器向服务器发出建立**TCP**连接的申请，完成三次握手后，连接通道建立
6. 若使用了HTTPS协议，则还会进行**SSL**握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2
8. 浏览器自动设置好请求头、协议版本、**cookie** ，发出**GET**请求
9. 服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。
10. 浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要**保留TCP**连接。
11. 浏览器根据响应**状态码**决定如何处理这一次响应
12. 浏览器根据响应头中的Content-Type字段识别响应类型，如果是text/html，则对响应体的内容进行**HTML解析**，否则做其他处理
13. 浏览器根据响应头的其他内容完成**缓存、cookie的设置**
14. 浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源
15. 解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），随后对渲染树中的每个节点计算位置和大小（reflow），最后把每个节点利用GPU绘制到屏幕（repaint）
16. 在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件

## 什么是WEBPACK

- 开发环境和生产环境要求完全不同，所以需要工程化，需要 webpack这样的打包工具
- webpack 把一切视为模块，从入口模块为起点，分析出所有的依赖关系，最终生成适合生产环境的项目文件
- 就是将适合开发环境的文件转为适合生成环境的文件（不关注代码运行）

- 打包过程

  1. 初始化

     合并参数和文件中的配置，生成最终的配置

     1. 编译

        1. 创建chunk，会从入口模块开始，寻找所有的依赖模块。
           1. fs读取文件内容
           2. 匹配 loader
           3. 生成抽象语法树
           4. 记录依赖的模块到 dependences 数组中
           5. 然后替换掉原先的依赖函数（__webpack_reuquire__）
           6. 将转换后的模块内容和模块路径记录下来
           7. 递归查找记录 dependences 数组中的模块
           8. 过程中对记录过的模块不会分析记录
           9. 每个记录会生成一个 contenthash
        2. 就是最终要输出的文件地址，以及文件内容，生成一个 chunkhash
        3. 合并不同chunk assets，生成一个 hash


  2. 输出

     根据合并后的chunk assets输出成文件，也就是 bundle

- 打包工具还有

  - Parcel

  - Vite

## Loader和Plugin

**loader**

loader本质上就是一个函数，接受一个字符串，返回一个新的字符串。在编译过程中，读取模块的源码之后，会寻找配置中合适的loader执行。

- style-loader: 将css添加到DOM的内联样式标签style里
- css-loader :允许将css文件通过require的方式引入，并返回css代码
- less-loader: 处理less
- sass-loader: 处理sass
- postcss-loader: 用postcss来处理CSS
- file-loader: 分发文件到output目录并返回相对路径
- url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url
- babel-loader :用babel来转换ES6文件到ES

**plugin**

plugin其本质是一个具有`apply`方法`javascript`对象，apply 方法会有个compiler参数，就是通过在compiler对象上注册钩子函数，参与webpack编译和生成

- HtmlWebpackPlugin
- clean-webpack-plugin
- copy-webpack-plugin



## 热替换

如果使用的是 `HMR`，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用

1. webpack-dev-server 检测到模块的变化，于是通过 webscoket **通知有变化**
2. 客户端收到消息后，通过 ajax 发送请求给服务端**想知道哪些模块变化了**
3. 服务器**告知哪些模块发生了变动**，同时告诉客户端这次打包产生的新 hash 值
4. 客户端再次用过去的 hash 值，以 **JSONP** 的方式**请求变动的模块**
5. 服务器**响应一个函数调用**，用于更新模块的代码



## ES6和CommonJS

1. CMJ 是社区标准，ESM 是官方标准
2. CMJ 是使用 API 实现的模块化，ESM 是使用新语法实现的模块化
3. CMJ 仅在 node 环境中支持，ESM 各种环境均支持
4. CMJ 是动态的依赖，同步执行。ESM 既支持动态，也支持静态，动态依赖是异步执行的。
5. ESM 导入时有符号绑定，CMJ 只是普通函数调用和赋值

## Babel

babel主要用于将 JS 语言代码编译成兼容性更好的代码。

它其实本身做的事情并不多，它负责将 JS 代码**编译成为 AST**，然后依托其生态中的各种插件对 AST 中的语法和 API 进行处理

## Node是什么

`Node.js` 是一个基于 v8引擎的开源、跨平台**的 `JavaScript` 运行时环境，具有**非IO阻塞、事件驱动**的特点

## Buffer

在`Node`应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而`Buffer`就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据

buffer类似一个数组，数组每一项就是一个字节。

如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理，这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 `RAM` 中

## Stream

流（Stream），是一个端到端信息交换的一种数据传输手段，方式是**有顺序的、逐块**读取或写入数据内容

流可以分成三部分：`source`、`dest`、`pipe`

在`source`和`dest`之间有一个连接的管道`pipe`,它的基本语法是`source.pipe(dest)`，`source`和`dest`就是通过pipe连接，让数据从`source`流向了`dest`，

- 可写流：内存流向源头的流。例如 fs.createWriteStream() 可以使用流将数据写入文件
- 可读流： 源头流向内存的流。例如fs.createReadStream() 可以从文件读取
- 双工流： 既可读又可写的流。例如 net.Socket
- 转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据



## 什么是SPA

单页面应用，是加载单个HTML 页面，在用户与应用程序交互时使用ajax动态更新该页面的Web应用程序。

优势：

- 具有桌面应用的即时性、网站的可移植性和可访问性
- 用户体验好、快，内容的改变不需要重新加载整个页面
- 良好的前后端分离，分工更明确

缺点：

- 不利于SEO
- 首次渲染速度相对较慢





## 组合式API的优势

- 在逻辑组织和逻辑复用方面，`Composition API`是优于`Options API`（混入命名冲突，来源不清）
- 因为`Composition API`几乎是函数，会有更好的类型推断。
- `Composition API`对 `tree-shaking` 友好，代码也更容易压缩
- `Composition API`中见不到`this`的使用，减少了`this`指向不明的情况
- 如果是小型组件，可以继续使用`Options API`，也是十分友好的



## 原型、原型链

- 原型是JavaScript语言实现属性继承和共享的方式

- 每个对象都有自己的原型对象，就是构造函数的 prototype 属性

- 原型对象也可能拥有原型，这样就组成了原型链

- 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾

## 闭包

- **闭包**（closure）是一个函数以及其捆绑的**词法环境**引用的组合

- 闭包让开发者可以从内部函数访问外部函数的作用域

- 闭包会随着函数的创建而被同时创建

- 闭包是利用作用域机制实现的。换句话说，就是闭包的内部函数持有对外部函数的变量对象的引用。即使外部函数已经结束执行，闭包能够访问外部函数中的变量，不会被垃圾回收掉

  

## 执行上下文和执行上下文栈

- **执行上下文**指的是，函数运行时，会在内存中开辟一块空间作为函数执行的环境，包括 this 的值、变量对象 VO（参数、局部变量、内部函数）

- **执行上下文栈**就指的是所有执行上下文组成的空间。新创建的执行上下文就放入栈顶，而js引擎使用的始终是栈顶的执行上下文



## 作用域和作用域链

- javaScript中作用域就是指词法作用域，在创建时就可见了。指 js 中变量的可见范围

  - 全局作用域
  
  
    - 函数作用域
  
  
  
    - 块级作用域
  
  
  
    - eval 作用域
  


- 当前作用域中查找（是否存在该变量），如果找到了就直接使用。否则就会向上层作用域逐级查找，直到找到全局作用域为止。这个查找过程形成了作用域链。
- 其实本质是以创建当前执行上下文的函数为桥梁，找到函数声明创建时的执行上下文中的 vo 对象

## 线程和进程

- 进程是程序的实体，进程是系统资源分配与调度的基本单位

- 而线程是系统运算调度的基本单位。

- 进程是线程的容器，一个进程可以同时并发多个线程

- 线程是进程中的实际运作单位，同一个进程中的线程可以共享资源

## Axios二次封装

 `axios.create`可以创建一个实例用于二次封装

- **设置接口请求前缀**：根据开发、测试、生产环境的不同，前缀需要加以区分
- **请求头** : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)
- **状态码**: 根据接口返回的不同`status` ， 来执行不同的业务，这块需要和后端约定好
- **请求方法**：根据`get`、`post`等方法进行一个再次封装，使用起来更为方便
- **请求拦截**
- **响应拦截**

把封装后的方法暴露出去

还会在此之上对每个api封装一个方法

## Histroy模式部署

`hash` 模式下，仅 `hash` 符号之前的内容会被包含在请求中，因此对于服务端来说，即使没有配置`location`，也不会返回404错误

当我们在 index之外的页面执行刷新操作时，服务器中 是没有相关配置的，所以就会出现 404 的情况

```nginx
  location / {
    index  /data/dist/index.html;
    try_files $uri $uri/ /index.html;
  }
```



## 服务端渲染

`SSR`解决方案，后端渲染出完整的首屏的`dom`结构返回，前端拿到的内容包括首屏及完整`spa`结构，应用激活后依然按照`spa`方式运行，再次跳转路由就不需要走服务端



## vite

- **在开发阶段**

  - webpack是先打包，然后再启动服务器，请求服务器时直接响应打包结果

  - vite是直接启动服务器，请求哪个模块再对哪个模块进行实时编译。这是利用了现代浏览器对esmodule的支持，会自动向依赖的module发出请求。而在HMR方面，当改动了一个模块，浏览器只需要重新请求该模块即可，而webpack需要重新编译一遍。

- 在生产阶段
  - vite用的还是用的传统打包方式 rollup，所以区别不大

因此，vite和webpack就在一些地方产生了差异：

- vite在开发模式下启动服务器速度非常快，并且热替换也不需要重新打包
- vite在开发阶段要求浏览器必须支持esmodule
- vite开发和生产环境可能不一致
- vite鼓励0配置，webpack的配置会比较繁琐

## Pinia

PiniaPinia 是为 Vue 3 设计的公共状态管理库

- 支持组合式API

- 删除mutations
- 与TS兼容性好
- 没有模块嵌套
- 更加轻量 

## express 和 koa 的区别

原版人马打造，koa 是 express 的升级版本

- 改为 async await ，避免回调地狱，处理错误更加简单
- 中间件改为洋葱模型
  - 执行await next（）前的代码
  - 下一个中间件
  - 执行 await next（）后的代码
- 去除内置中间件



## ArrayBuffer

`ArrayBuffer` 是一种通用的、固定长度的二进制数据缓冲区，它用于存储原始的二进制数据。`ArrayBuffer` 的长度是固定的，一旦分配后就无法改,实际上只是一块内存区域，它没有提供直接访问或操作数据的方法。相反，它是 `TypedArray` 和 `DataView` 的基础。

`TypedArray` 和 `DataView` 都是对 `ArrayBuffer` 的视图，它们可以直接访问和操作 `ArrayBuffer` 中的数据。

- `TypedArray` 数据都视为某一种类型
- `DataView` 数据可视为任意类型，由偏移读取时决定



## 严格模式

**特点**

- 没有声明的变量不能使用
- 函数内部 _this_ 值为 _undefined_
- 删除变量和不存在的属性会报错
- 函数中相同的形参名会报错
- 禁止八进制表示法
- 创设 _eval_ 作用域
- 保留字

**优势**

- 消除 *Javascript* 语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的 *Javascript* 做好铺垫。



## 函数式编程

函数式编程（Functional Programming，简称 FP）是一种编程范式，强调使用纯函数（Pure Functions）和不可变数据（Immutable Data），并通过组合函数和高阶函数来构建复杂的程序。

**优点**

- 更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况
- 更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响
- 更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性
- 隐性好处。减少代码量，提高维护性

**缺点**

- 性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销

- 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式

- 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作

  

## axios 和 fetch

- axios 基于 xhr （浏览器端）和 http（node 端）封装，fetch 在两端都原生支持

- 对比

  - axios
    - 简单
    - 返回结果自动转换
    - 错误处理方便
    - 兼容性好
    - 需要安装库
    - 可以加拦截器

   - fetch
     	-  原生 api
     	- 可以获取ReadableStream
     	- 错误处理复杂 ，404 500等不会主动抛错
     	- 兼容性差
     	- 不支持拦截器



## 微前端

- 类似于微服务的架构，是由独立开发、测试、部署多个前端应用组成整体，用户看来仍然是内聚的单个产品
- 优点

  - 独立开发部署
  - 技术栈无关
  - 渐进式升级和迁移
- 缺点

  - 复杂增加学习成本
  - 统一性
- 实现方式
  - iframe
    - 优点
      - 原生支持
      - 简单
      - 完全隔离
      - 可跨域
    
    - 缺点
      - seo 不好
      - 事件无法冒泡
      - 登录状态无法共享
      - 无法共享基础库
      - 通讯不方便（postMessage）
    
  - single-spa
  - qiankun
  



## qiankun

- 通讯
  - props + 订阅发布
  - 使用官方提供的api GlobalState

- 沙箱
  - 



keep-alive



## DevOps

- 定义：devops 是开发和运维的合成词，是指重视开发人员与运维人员沟通合作的文化或惯例。
- 行为：通过自动化软件交付流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。
- 使用场景：传统模式开发和运维是独立的，但是面对新的开发模式，比如敏捷开发，就可以引入 devops 实现各部门的紧密合作。

- 具体流程

  - Dev: Plan(规划)、Code(编码)、Build(构建)、Test(测试)

  - Ops：Release(发布)、Deploy(部署)、Operate(运维)、Monitor(监控)



## 正向代理与反向代理

- 正向代理代理
  - 代理客户端
  - vpn、跨域代理服务器
- 反向代理
  - 代理服务器
  - nginx

## 什么是 ts

定义：微软开发的， JS的超集，  **可选的**、**静态的**、**类型系统**

- 类型系统

​	对代码中所有的标识符（变量、函数、参数、返回值）进行类型检查

- 可选的

​	学习曲线非常平滑

- 静态的(在运行之前)

  类型检查发生的时间，在编译的时候，而非运行时
